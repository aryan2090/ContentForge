{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js Project with TypeScript and Core Dependencies",
        "description": "Set up the Next.js 14+ project with TypeScript, Tailwind CSS, and App Router. Install and configure all core dependencies including shadcn/ui component library.",
        "details": "1. Initialize Next.js project:\n   ```bash\n   npx create-next-app@latest contentforge --typescript --tailwind --eslint --app --src-dir\n   ```\n\n2. Install core dependencies:\n   ```bash\n   npm install @prisma/client bcryptjs zod react-hook-form @hookform/resolvers\n   npm install -D prisma @types/bcryptjs\n   ```\n\n3. Initialize shadcn/ui:\n   ```bash\n   npx shadcn@latest init\n   npx shadcn@latest add button input card select label textarea tabs avatar dropdown-menu dialog toast form\n   ```\n\n4. Create directory structure as per PRD:\n   - src/app/(auth)/ - Auth route group\n   - src/app/(dashboard)/ - Protected dashboard routes\n   - src/app/api/ - API routes\n   - src/components/ui/ - Base UI components (shadcn)\n   - src/components/auth/ - Auth components\n   - src/components/brand/ - Brand management\n   - src/components/generate/ - Generation UI\n   - src/components/layout/ - Layout components\n   - src/lib/auth/ - Auth logic\n   - src/lib/db/ - Database client\n   - src/lib/ai/ - AI API clients\n   - src/lib/email/ - Email service\n   - src/lib/utils/ - Utilities\n   - src/types/ - TypeScript types\n\n5. Configure TypeScript paths in tsconfig.json:\n   ```json\n   {\n     \"compilerOptions\": {\n       \"paths\": {\n         \"@/*\": [\"./src/*\"]\n       }\n     }\n   }\n   ```\n\n6. Set up environment variables (.env.local):\n   - DATABASE_URL\n   - NEXTAUTH_SECRET\n   - NEXTAUTH_URL\n   - GOOGLE_AI_API_KEY\n   - RESEND_API_KEY",
        "testStrategy": "1. Verify `npm run dev` starts without errors\n2. Verify TypeScript compilation with `npm run build`\n3. Confirm all directories exist and are properly structured\n4. Test shadcn/ui components render correctly by importing Button in a test page\n5. Verify Tailwind CSS is working with a styled component",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Set Up Prisma Schema and Vercel Postgres Database",
        "description": "Configure Prisma ORM with PostgreSQL schema defining users, brands, generations, and sessions tables. Provision Vercel Postgres database and deploy schema.",
        "details": "1. Initialize Prisma:\n   ```bash\n   npx prisma init\n   ```\n\n2. Create Prisma schema (prisma/schema.prisma):\n   ```prisma\n   generator client {\n     provider = \"prisma-client-js\"\n   }\n\n   datasource db {\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n     directUrl = env(\"DIRECT_URL\")\n   }\n\n   model User {\n     id           String       @id @default(uuid())\n     email        String       @unique\n     passwordHash String\n     createdAt    DateTime     @default(now())\n     updatedAt    DateTime     @updatedAt\n     brand        Brand?\n     generations  Generation[]\n     sessions     Session[]\n   }\n\n   model Brand {\n     id               String   @id @default(uuid())\n     userId           String   @unique\n     user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n     name             String\n     logoUrl          String?\n     primaryColor     String   @default(\"#000000\")\n     secondaryColor   String   @default(\"#ffffff\")\n     accentColor      String   @default(\"#3b82f6\")\n     voiceDescription String?\n     industry         String   @default(\"other\")\n     createdAt        DateTime @default(now())\n     updatedAt        DateTime @updatedAt\n   }\n\n   enum ContentType {\n     VIDEO\n     IMAGE\n   }\n\n   model Generation {\n     id           String      @id @default(uuid())\n     userId       String\n     user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)\n     prompt       String\n     contentType  ContentType\n     model        String\n     aspectRatio  String\n     duration     Int?\n     resolution   String\n     includeBrand Boolean     @default(false)\n     createdAt    DateTime    @default(now())\n   }\n\n   model Session {\n     id        String   @id @default(uuid())\n     userId    String\n     user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n     token     String   @unique\n     expiresAt DateTime\n     createdAt DateTime @default(now())\n   }\n   ```\n\n3. Provision Vercel Postgres:\n   - Create database in Vercel dashboard (Storage > Create Database > Postgres)\n   - Copy connection strings to .env.local\n   - Set DATABASE_URL (pooled) and DIRECT_URL (direct)\n\n4. Create Prisma client singleton (src/lib/db/index.ts):\n   ```typescript\n   import { PrismaClient } from '@prisma/client'\n\n   const globalForPrisma = globalThis as unknown as {\n     prisma: PrismaClient | undefined\n   }\n\n   export const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\n   if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n   ```\n\n5. Deploy schema:\n   ```bash\n   npx prisma db push\n   npx prisma generate\n   ```",
        "testStrategy": "1. Run `npx prisma db push` - should succeed without errors\n2. Run `npx prisma studio` - should open and display empty tables\n3. Test connection with a simple script that creates and deletes a test user\n4. Verify schema generates TypeScript types with `npx prisma generate`\n5. Test Prisma client import works in a test file",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create TypeScript Types and Zod Validation Schemas",
        "description": "Define TypeScript types and Zod validation schemas for all entities including User, Brand, Generation, and API inputs/outputs.",
        "details": "1. Create auth types (src/types/auth.ts):\n   ```typescript\n   import { z } from 'zod'\n\n   export const registerSchema = z.object({\n     email: z.string().email('Invalid email address'),\n     password: z.string().min(8, 'Password must be at least 8 characters'),\n     confirmPassword: z.string()\n   }).refine(data => data.password === data.confirmPassword, {\n     message: 'Passwords do not match',\n     path: ['confirmPassword']\n   })\n\n   export const loginSchema = z.object({\n     email: z.string().email('Invalid email address'),\n     password: z.string().min(1, 'Password is required')\n   })\n\n   export const passwordResetRequestSchema = z.object({\n     email: z.string().email('Invalid email address')\n   })\n\n   export const passwordResetSchema = z.object({\n     token: z.string().min(1),\n     password: z.string().min(8),\n     confirmPassword: z.string()\n   }).refine(data => data.password === data.confirmPassword, {\n     message: 'Passwords do not match',\n     path: ['confirmPassword']\n   })\n\n   export type RegisterInput = z.infer<typeof registerSchema>\n   export type LoginInput = z.infer<typeof loginSchema>\n   ```\n\n2. Create brand types (src/types/brand.ts):\n   ```typescript\n   import { z } from 'zod'\n\n   const hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/\n\n   export const brandSchema = z.object({\n     name: z.string().min(1, 'Brand name is required').max(100),\n     logoUrl: z.string().url().optional().nullable(),\n     primaryColor: z.string().regex(hexColorRegex, 'Invalid hex color').default('#000000'),\n     secondaryColor: z.string().regex(hexColorRegex, 'Invalid hex color').default('#ffffff'),\n     accentColor: z.string().regex(hexColorRegex, 'Invalid hex color').default('#3b82f6'),\n     voiceDescription: z.string().max(500).optional().nullable(),\n     industry: z.string().default('other')\n   })\n\n   export const INDUSTRIES = [\n     'technology', 'retail', 'food', 'health', 'finance',\n     'education', 'entertainment', 'travel', 'fashion', 'other'\n   ] as const\n\n   export type BrandInput = z.infer<typeof brandSchema>\n   ```\n\n3. Create generation types (src/types/generation.ts):\n   ```typescript\n   import { z } from 'zod'\n\n   export const VIDEO_MODELS = [\n     { id: 'veo-3.1', label: 'Veo 3.1 (Best quality)', price: 0.40, unit: '$/second' },\n     { id: 'veo-3.1-fast', label: 'Veo 3.1 Fast', price: 0.15, unit: '$/second' },\n     { id: 'veo-3', label: 'Veo 3', price: 0.40, unit: '$/second' },\n     { id: 'veo-2', label: 'Veo 2 (Budget)', price: 0.35, unit: '$/second' }\n   ] as const\n\n   export const IMAGE_MODELS = [\n     { id: 'gemini-3-pro-image', label: 'Nano Banana Pro (4K)', price: 0.15, unit: '$/image' },\n     { id: 'gemini-2.5-flash-image', label: 'Nano Banana (Fast)', price: 0.04, unit: '$/image' }\n   ] as const\n\n   export const generateVideoSchema = z.object({\n     prompt: z.string().min(1).max(1000),\n     model: z.enum(['veo-3.1', 'veo-3.1-fast', 'veo-3', 'veo-2']).default('veo-3.1-fast'),\n     aspectRatio: z.enum(['9:16', '16:9']).default('9:16'),\n     duration: z.enum([4, 6, 8]).default(4),\n     resolution: z.enum(['720p', '1080p']).default('1080p'),\n     includeBrand: z.boolean().default(false)\n   })\n\n   export const generateImageSchema = z.object({\n     prompt: z.string().min(1).max(1000),\n     model: z.enum(['gemini-3-pro-image', 'gemini-2.5-flash-image']).default('gemini-2.5-flash-image'),\n     aspectRatio: z.enum(['9:16', '16:9', '1:1']).default('1:1'),\n     resolution: z.enum(['1080p', '2K', '4K']).default('1080p'),\n     includeBrand: z.boolean().default(false)\n   })\n\n   export type GenerateVideoInput = z.infer<typeof generateVideoSchema>\n   export type GenerateImageInput = z.infer<typeof generateImageSchema>\n\n   export function getEstimatedCost(modelId: string, duration?: number): number {\n     const videoModel = VIDEO_MODELS.find(m => m.id === modelId)\n     if (videoModel && duration) return videoModel.price * duration\n     const imageModel = IMAGE_MODELS.find(m => m.id === modelId)\n     if (imageModel) return imageModel.price\n     return 0\n   }\n   ```\n\n4. Create API response types (src/types/api.ts):\n   ```typescript\n   export type ApiResponse<T> = \n     | { success: true; data: T }\n     | { success: false; error: string }\n\n   export type PaginatedResponse<T> = {\n     data: T[]\n     page: number\n     pageSize: number\n     total: number\n     hasMore: boolean\n   }\n   ```\n\n5. Create barrel export (src/types/index.ts)",
        "testStrategy": "1. Write unit tests for each Zod schema validating happy path inputs\n2. Test edge cases: invalid email formats, short passwords, invalid hex colors\n3. Test schema refinements (password confirmation matching)\n4. Verify TypeScript types infer correctly from schemas\n5. Test getEstimatedCost function with various model/duration combinations",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Error Handling Utilities",
        "description": "Create centralized error handling utilities including custom error classes, error handler functions, and input validation helpers for consistent error management across the application.",
        "details": "1. Create custom error class (src/lib/utils/errors.ts):\n   ```typescript\n   export class AppError extends Error {\n     constructor(\n       message: string,\n       public statusCode: number = 500,\n       public code?: string\n     ) {\n       super(message)\n       this.name = 'AppError'\n     }\n\n     static badRequest(message: string, code?: string) {\n       return new AppError(message, 400, code)\n     }\n\n     static unauthorized(message = 'Unauthorized') {\n       return new AppError(message, 401, 'UNAUTHORIZED')\n     }\n\n     static forbidden(message = 'Forbidden') {\n       return new AppError(message, 403, 'FORBIDDEN')\n     }\n\n     static notFound(message = 'Not found') {\n       return new AppError(message, 404, 'NOT_FOUND')\n     }\n\n     static tooManyRequests(message = 'Too many requests') {\n       return new AppError(message, 429, 'RATE_LIMIT')\n     }\n\n     static internal(message = 'Internal server error') {\n       return new AppError(message, 500, 'INTERNAL_ERROR')\n     }\n   }\n\n   export function handleError(error: unknown): { message: string; statusCode: number; code?: string } {\n     if (error instanceof AppError) {\n       return { message: error.message, statusCode: error.statusCode, code: error.code }\n     }\n     if (error instanceof Error) {\n       console.error('Unhandled error:', error)\n       return { message: 'An unexpected error occurred', statusCode: 500 }\n     }\n     return { message: 'An unknown error occurred', statusCode: 500 }\n   }\n   ```\n\n2. Create validation helper (src/lib/utils/validation.ts):\n   ```typescript\n   import { ZodSchema, ZodError } from 'zod'\n   import { AppError } from './errors'\n\n   export function validateInput<T>(schema: ZodSchema<T>, data: unknown): T {\n     try {\n       return schema.parse(data)\n     } catch (error) {\n       if (error instanceof ZodError) {\n         const message = error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')\n         throw AppError.badRequest(message, 'VALIDATION_ERROR')\n       }\n       throw error\n     }\n   }\n\n   export function formatZodErrors(error: ZodError): Record<string, string> {\n     const errors: Record<string, string> = {}\n     error.errors.forEach(err => {\n       const path = err.path.join('.')\n       errors[path] = err.message\n     })\n     return errors\n   }\n   ```\n\n3. Create API response helpers (src/lib/utils/api.ts):\n   ```typescript\n   import { NextResponse } from 'next/server'\n   import { handleError } from './errors'\n\n   export function successResponse<T>(data: T, status = 200) {\n     return NextResponse.json({ success: true, data }, { status })\n   }\n\n   export function errorResponse(error: unknown) {\n     const { message, statusCode, code } = handleError(error)\n     return NextResponse.json(\n       { success: false, error: message, code },\n       { status: statusCode }\n     )\n   }\n   ```\n\n4. Create barrel export (src/lib/utils/index.ts):\n   ```typescript\n   export * from './errors'\n   export * from './validation'\n   export * from './api'\n   export { cn } from './cn' // from shadcn\n   ```",
        "testStrategy": "1. Unit test AppError static methods create correct error types\n2. Test handleError returns proper format for AppError vs generic Error\n3. Test validateInput throws AppError for invalid Zod schemas\n4. Test formatZodErrors produces correct error object structure\n5. Integration test API response helpers return correct NextResponse format",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Authentication System with NextAuth.js",
        "description": "Build complete authentication system including password hashing, session management, and auth API routes using NextAuth.js v5 (Auth.js) with credentials provider.",
        "details": "1. Install NextAuth.js:\n   ```bash\n   npm install next-auth@beta\n   ```\n\n2. Create password utilities (src/lib/auth/password.ts):\n   ```typescript\n   import bcrypt from 'bcryptjs'\n\n   const SALT_ROUNDS = 12\n\n   export async function hashPassword(password: string): Promise<string> {\n     return bcrypt.hash(password, SALT_ROUNDS)\n   }\n\n   export async function verifyPassword(password: string, hash: string): Promise<boolean> {\n     return bcrypt.compare(password, hash)\n   }\n   ```\n\n3. Create NextAuth configuration (src/lib/auth/index.ts):\n   ```typescript\n   import NextAuth from 'next-auth'\n   import Credentials from 'next-auth/providers/credentials'\n   import { prisma } from '@/lib/db'\n   import { verifyPassword } from './password'\n   import { loginSchema } from '@/types/auth'\n\n   export const { handlers, signIn, signOut, auth } = NextAuth({\n     providers: [\n       Credentials({\n         credentials: {\n           email: { label: 'Email', type: 'email' },\n           password: { label: 'Password', type: 'password' }\n         },\n         async authorize(credentials) {\n           const parsed = loginSchema.safeParse(credentials)\n           if (!parsed.success) return null\n\n           const user = await prisma.user.findUnique({\n             where: { email: parsed.data.email }\n           })\n           if (!user) return null\n\n           const valid = await verifyPassword(parsed.data.password, user.passwordHash)\n           if (!valid) return null\n\n           return { id: user.id, email: user.email }\n         }\n       })\n     ],\n     callbacks: {\n       jwt({ token, user }) {\n         if (user) token.id = user.id\n         return token\n       },\n       session({ session, token }) {\n         if (session.user) session.user.id = token.id as string\n         return session\n       }\n     },\n     pages: {\n       signIn: '/login'\n     }\n   })\n   ```\n\n4. Create auth route handler (src/app/api/auth/[...nextauth]/route.ts):\n   ```typescript\n   import { handlers } from '@/lib/auth'\n   export const { GET, POST } = handlers\n   ```\n\n5. Create registration endpoint (src/app/api/auth/register/route.ts):\n   ```typescript\n   import { NextRequest } from 'next/server'\n   import { prisma } from '@/lib/db'\n   import { hashPassword } from '@/lib/auth/password'\n   import { registerSchema } from '@/types/auth'\n   import { validateInput, successResponse, errorResponse, AppError } from '@/lib/utils'\n\n   export async function POST(req: NextRequest) {\n     try {\n       const body = await req.json()\n       const { email, password } = validateInput(registerSchema, body)\n\n       const existing = await prisma.user.findUnique({ where: { email } })\n       if (existing) throw AppError.badRequest('Email already registered')\n\n       const passwordHash = await hashPassword(password)\n       const user = await prisma.user.create({\n         data: { email, passwordHash },\n         select: { id: true, email: true }\n       })\n\n       return successResponse(user, 201)\n     } catch (error) {\n       return errorResponse(error)\n     }\n   }\n   ```\n\n6. Create session helper (src/lib/auth/session.ts):\n   ```typescript\n   import { auth } from './index'\n   import { cache } from 'react'\n\n   export const getSession = cache(async () => {\n     const session = await auth()\n     return session\n   })\n\n   export async function requireAuth() {\n     const session = await getSession()\n     if (!session?.user) throw new Error('Unauthorized')\n     return session.user\n   }\n   ```\n\n7. Add middleware for protected routes (src/middleware.ts):\n   ```typescript\n   export { auth as middleware } from '@/lib/auth'\n\n   export const config = {\n     matcher: ['/dashboard/:path*', '/generate/:path*', '/brand/:path*', '/history/:path*']\n   }\n   ```",
        "testStrategy": "1. Unit test hashPassword produces different hashes for same password (salt)\n2. Unit test verifyPassword correctly validates passwords\n3. Integration test registration creates user in database\n4. Integration test registration rejects duplicate emails\n5. Integration test login returns session for valid credentials\n6. Integration test login rejects invalid credentials\n7. E2E test full registration and login flow",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Build Authentication UI Components and Pages",
        "description": "Create authentication form components (LoginForm, SignupForm, PasswordResetForm) and corresponding pages (/login, /signup, /forgot-password, /reset-password).",
        "details": "1. Create login form component (src/components/auth/login-form.tsx):\n   ```typescript\n   'use client'\n   import { useState } from 'react'\n   import { useForm } from 'react-hook-form'\n   import { zodResolver } from '@hookform/resolvers/zod'\n   import { signIn } from 'next-auth/react'\n   import { useRouter } from 'next/navigation'\n   import { loginSchema, LoginInput } from '@/types/auth'\n   import { Button } from '@/components/ui/button'\n   import { Input } from '@/components/ui/input'\n   import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form'\n\n   export function LoginForm() {\n     const router = useRouter()\n     const [error, setError] = useState<string | null>(null)\n     const form = useForm<LoginInput>({\n       resolver: zodResolver(loginSchema),\n       defaultValues: { email: '', password: '' }\n     })\n\n     async function onSubmit(data: LoginInput) {\n       setError(null)\n       const result = await signIn('credentials', {\n         email: data.email,\n         password: data.password,\n         redirect: false\n       })\n       if (result?.error) {\n         setError('Invalid email or password')\n       } else {\n         router.push('/dashboard')\n         router.refresh()\n       }\n     }\n\n     return (\n       <Form {...form}>\n         <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n           {error && <p className=\"text-sm text-red-500\">{error}</p>}\n           <FormField\n             control={form.control}\n             name=\"email\"\n             render={({ field }) => (\n               <FormItem>\n                 <FormLabel>Email</FormLabel>\n                 <FormControl>\n                   <Input type=\"email\" {...field} />\n                 </FormControl>\n                 <FormMessage />\n               </FormItem>\n             )}\n           />\n           <FormField\n             control={form.control}\n             name=\"password\"\n             render={({ field }) => (\n               <FormItem>\n                 <FormLabel>Password</FormLabel>\n                 <FormControl>\n                   <Input type=\"password\" {...field} />\n                 </FormControl>\n                 <FormMessage />\n               </FormItem>\n             )}\n           />\n           <Button type=\"submit\" className=\"w-full\" disabled={form.formState.isSubmitting}>\n             {form.formState.isSubmitting ? 'Signing in...' : 'Sign In'}\n           </Button>\n         </form>\n       </Form>\n     )\n   }\n   ```\n\n2. Create signup form component (src/components/auth/signup-form.tsx) - similar structure with registration endpoint call\n\n3. Create auth pages:\n   - src/app/(auth)/login/page.tsx\n   - src/app/(auth)/signup/page.tsx\n   - src/app/(auth)/forgot-password/page.tsx\n   - src/app/(auth)/reset-password/page.tsx\n\n4. Create auth layout (src/app/(auth)/layout.tsx):\n   ```typescript\n   import { redirect } from 'next/navigation'\n   import { getSession } from '@/lib/auth/session'\n\n   export default async function AuthLayout({ children }: { children: React.ReactNode }) {\n     const session = await getSession()\n     if (session) redirect('/dashboard')\n     return (\n       <div className=\"min-h-screen flex items-center justify-center bg-gray-50\">\n         <div className=\"w-full max-w-md p-8\">\n           {children}\n         </div>\n       </div>\n     )\n   }\n   ```\n\n5. Add links between auth pages (Login -> Signup, Forgot Password links)",
        "testStrategy": "1. Component test: LoginForm renders all fields correctly\n2. Component test: Form validation displays error messages\n3. Component test: Submit button shows loading state\n4. E2E test: Navigate to /login, fill form, submit, verify redirect to dashboard\n5. E2E test: Navigate to /signup, complete registration, verify redirect\n6. E2E test: Authenticated user visiting /login is redirected to dashboard",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Brand Management API and UI",
        "description": "Create brand profile CRUD API endpoints and build brand management UI including BrandForm, ColorPicker, LogoUploader components and the /brand page.",
        "details": "1. Create brand API route (src/app/api/brand/route.ts):\n   ```typescript\n   import { NextRequest } from 'next/server'\n   import { prisma } from '@/lib/db'\n   import { requireAuth } from '@/lib/auth/session'\n   import { brandSchema } from '@/types/brand'\n   import { validateInput, successResponse, errorResponse } from '@/lib/utils'\n\n   export async function GET() {\n     try {\n       const user = await requireAuth()\n       const brand = await prisma.brand.findUnique({\n         where: { userId: user.id }\n       })\n       return successResponse(brand)\n     } catch (error) {\n       return errorResponse(error)\n     }\n   }\n\n   export async function POST(req: NextRequest) {\n     try {\n       const user = await requireAuth()\n       const body = await req.json()\n       const data = validateInput(brandSchema, body)\n\n       const brand = await prisma.brand.upsert({\n         where: { userId: user.id },\n         create: { ...data, userId: user.id },\n         update: data\n       })\n       return successResponse(brand)\n     } catch (error) {\n       return errorResponse(error)\n     }\n   }\n   ```\n\n2. Create color picker component (src/components/brand/color-picker.tsx):\n   ```typescript\n   'use client'\n   import { Input } from '@/components/ui/input'\n   import { Label } from '@/components/ui/label'\n\n   interface ColorPickerProps {\n     label: string\n     value: string\n     onChange: (value: string) => void\n   }\n\n   export function ColorPicker({ label, value, onChange }: ColorPickerProps) {\n     return (\n       <div className=\"space-y-2\">\n         <Label>{label}</Label>\n         <div className=\"flex gap-2\">\n           <input\n             type=\"color\"\n             value={value}\n             onChange={(e) => onChange(e.target.value)}\n             className=\"h-10 w-16 cursor-pointer rounded border\"\n           />\n           <Input\n             value={value}\n             onChange={(e) => onChange(e.target.value)}\n             placeholder=\"#000000\"\n             className=\"font-mono\"\n           />\n         </div>\n       </div>\n     )\n   }\n   ```\n\n3. Create logo uploader (src/components/brand/logo-uploader.tsx):\n   - Accept PNG, JPG, SVG up to 5MB\n   - Preview uploaded logo\n   - Store temporarily (local state) for MVP, or integrate with upload service\n\n4. Create brand form (src/components/brand/brand-form.tsx):\n   - Combine name, industry, colors, voice description, logo\n   - Use react-hook-form with brandSchema validation\n   - Save to /api/brand on submit\n\n5. Create brand page (src/app/(dashboard)/brand/page.tsx):\n   ```typescript\n   import { BrandForm } from '@/components/brand/brand-form'\n\n   export default function BrandPage() {\n     return (\n       <div className=\"container max-w-2xl py-8\">\n         <h1 className=\"text-2xl font-bold mb-6\">Brand Profile</h1>\n         <BrandForm />\n       </div>\n     )\n   }\n   ```\n\n6. Add industry dropdown with predefined options from INDUSTRIES constant",
        "testStrategy": "1. Integration test: GET /api/brand returns null for new user\n2. Integration test: POST /api/brand creates brand profile\n3. Integration test: POST /api/brand updates existing profile (upsert)\n4. Component test: ColorPicker updates value on color/text input\n5. Component test: BrandForm validates all fields\n6. E2E test: Navigate to /brand, fill form, submit, verify saved data persists on refresh",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate Google Veo and Gemini Image AI APIs",
        "description": "Implement AI client modules for Google Veo (video generation) and Gemini Image (image generation) APIs with model selection, polling for async video completion, and prompt enhancement.",
        "details": "1. Install Google AI SDK:\n   ```bash\n   npm install @google/generative-ai\n   ```\n\n2. Create models config (src/lib/ai/models.ts):\n   ```typescript\n   import { VIDEO_MODELS, IMAGE_MODELS } from '@/types/generation'\n\n   export { VIDEO_MODELS, IMAGE_MODELS }\n\n   export function getVideoModel(id: string) {\n     return VIDEO_MODELS.find(m => m.id === id) ?? VIDEO_MODELS[1] // default: veo-3.1-fast\n   }\n\n   export function getImageModel(id: string) {\n     return IMAGE_MODELS.find(m => m.id === id) ?? IMAGE_MODELS[1] // default: gemini-2.5-flash-image\n   }\n   ```\n\n3. Create Veo client (src/lib/ai/veo.ts):\n   ```typescript\n   import { GoogleGenerativeAI } from '@google/generative-ai'\n   import { GenerateVideoInput } from '@/types/generation'\n   import { AppError } from '@/lib/utils'\n\n   const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!)\n\n   export interface VideoGenerationResult {\n     videoUrl: string\n     durationSeconds: number\n   }\n\n   export async function generateVideo(\n     input: GenerateVideoInput,\n     brandContext?: string\n   ): Promise<VideoGenerationResult> {\n     const prompt = brandContext ? `${input.prompt}\\n\\nBrand context: ${brandContext}` : input.prompt\n\n     // Use the appropriate Veo model based on input.model\n     // Note: Actual API structure depends on Google's Veo API docs\n     // This is a placeholder implementation\n     const model = genAI.getGenerativeModel({ model: input.model })\n\n     // For video generation, Google uses async operations with polling\n     const operation = await model.generateContent({\n       contents: [{ role: 'user', parts: [{ text: prompt }] }],\n       generationConfig: {\n         // Video-specific config\n         aspectRatio: input.aspectRatio,\n         durationSeconds: input.duration,\n         resolution: input.resolution\n       }\n     })\n\n     // Poll for completion (placeholder - actual implementation depends on API)\n     const result = await pollForCompletion(operation)\n     return result\n   }\n\n   async function pollForCompletion(operation: any, maxAttempts = 60): Promise<VideoGenerationResult> {\n     // Implement polling logic with exponential backoff\n     // Throw AppError.internal if timeout\n   }\n   ```\n\n4. Create Gemini Image client (src/lib/ai/gemini-image.ts):\n   ```typescript\n   import { GoogleGenerativeAI } from '@google/generative-ai'\n   import { GenerateImageInput } from '@/types/generation'\n\n   const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!)\n\n   export interface ImageGenerationResult {\n     imageData: string // base64 or URL\n     mimeType: string\n   }\n\n   export async function generateImage(\n     input: GenerateImageInput,\n     brandContext?: string\n   ): Promise<ImageGenerationResult> {\n     const prompt = brandContext ? `${input.prompt}\\n\\nBrand context: ${brandContext}` : input.prompt\n\n     const model = genAI.getGenerativeModel({ model: input.model })\n\n     const result = await model.generateContent({\n       contents: [{ role: 'user', parts: [{ text: prompt }] }],\n       generationConfig: {\n         // Image-specific config\n         aspectRatio: input.aspectRatio,\n         resolution: input.resolution\n       }\n     })\n\n     // Extract image from response\n     return {\n       imageData: result.response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data ?? '',\n       mimeType: 'image/png'\n     }\n   }\n   ```\n\n5. Create prompt enhancer (src/lib/ai/prompt-enhancer.ts):\n   ```typescript\n   import { GoogleGenerativeAI } from '@google/generative-ai'\n\n   const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!)\n\n   export async function enhancePrompt(prompt: string, brandContext?: string): Promise<string> {\n     const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n\n     const systemPrompt = `You are a prompt engineer specializing in AI content generation.\n     Improve the following prompt for ${brandContext ? 'brand-aligned' : ''} social media content generation.\n     Make it more descriptive, specific, and likely to produce high-quality results.\n     Keep the enhanced prompt under 500 characters.\n     ${brandContext ? `Brand context: ${brandContext}` : ''}`\n\n     const result = await model.generateContent([\n       { role: 'user', parts: [{ text: `${systemPrompt}\\n\\nOriginal prompt: ${prompt}` }] }\n     ])\n\n     return result.response.text() || prompt\n   }\n   ```",
        "testStrategy": "1. Unit test with mocked Google AI SDK for video generation flow\n2. Unit test with mocked SDK for image generation flow\n3. Unit test prompt enhancer improves prompt quality\n4. Integration test (separate suite) with real API for video generation\n5. Integration test with real API for image generation\n6. Test error handling for API failures, timeouts, rate limits\n7. Test polling mechanism with various completion scenarios",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Build Content Generation API Routes and UI",
        "description": "Create generation API endpoints (/api/generate/video, /api/generate/image) and build the complete generation UI including PromptInput, FormatSelector, ModelSelector with pricing, and preview components.",
        "details": "1. Create video generation endpoint (src/app/api/generate/video/route.ts):\n   ```typescript\n   import { NextRequest } from 'next/server'\n   import { prisma } from '@/lib/db'\n   import { requireAuth } from '@/lib/auth/session'\n   import { generateVideoSchema } from '@/types/generation'\n   import { generateVideo } from '@/lib/ai/veo'\n   import { validateInput, successResponse, errorResponse, AppError } from '@/lib/utils'\n\n   export async function POST(req: NextRequest) {\n     try {\n       const user = await requireAuth()\n       const body = await req.json()\n       const input = validateInput(generateVideoSchema, body)\n\n       // Get brand context if requested\n       let brandContext: string | undefined\n       if (input.includeBrand) {\n         const brand = await prisma.brand.findUnique({ where: { userId: user.id } })\n         if (brand) {\n           brandContext = `Brand: ${brand.name}, Industry: ${brand.industry}, Colors: ${brand.primaryColor}, ${brand.secondaryColor}, ${brand.accentColor}. Voice: ${brand.voiceDescription || 'Professional'}`\n         }\n       }\n\n       const result = await generateVideo(input, brandContext)\n\n       // Log generation to history\n       await prisma.generation.create({\n         data: {\n           userId: user.id,\n           prompt: input.prompt,\n           contentType: 'VIDEO',\n           model: input.model,\n           aspectRatio: input.aspectRatio,\n           duration: input.duration,\n           resolution: input.resolution,\n           includeBrand: input.includeBrand\n         }\n       })\n\n       return successResponse(result)\n     } catch (error) {\n       return errorResponse(error)\n     }\n   }\n   ```\n\n2. Create image generation endpoint (src/app/api/generate/image/route.ts) - similar structure\n\n3. Create model selector component (src/components/generate/model-selector.tsx):\n   ```typescript\n   'use client'\n   import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'\n   import { VIDEO_MODELS, IMAGE_MODELS, getEstimatedCost } from '@/types/generation'\n\n   interface ModelSelectorProps {\n     type: 'video' | 'image'\n     value: string\n     onChange: (value: string) => void\n     duration?: number // for video cost calculation\n   }\n\n   export function ModelSelector({ type, value, onChange, duration }: ModelSelectorProps) {\n     const models = type === 'video' ? VIDEO_MODELS : IMAGE_MODELS\n     const estimatedCost = getEstimatedCost(value, duration)\n\n     return (\n       <div className=\"space-y-2\">\n         <Select value={value} onValueChange={onChange}>\n           <SelectTrigger>\n             <SelectValue />\n           </SelectTrigger>\n           <SelectContent>\n             {models.map(model => (\n               <SelectItem key={model.id} value={model.id}>\n                 {model.label} - {model.price} {model.unit}\n               </SelectItem>\n             ))}\n           </SelectContent>\n         </Select>\n         <p className=\"text-sm text-muted-foreground\">\n           Estimated cost: ${estimatedCost.toFixed(2)}\n         </p>\n       </div>\n     )\n   }\n   ```\n\n4. Create format selector (src/components/generate/format-selector.tsx) for aspect ratio, duration, resolution\n\n5. Create prompt input (src/components/generate/prompt-input.tsx) with enhance button\n\n6. Create video preview (src/components/generate/video-preview.tsx):\n   ```typescript\n   interface VideoPreviewProps {\n     url: string\n     onDownload: () => void\n   }\n\n   export function VideoPreview({ url, onDownload }: VideoPreviewProps) {\n     return (\n       <div className=\"space-y-4\">\n         <video src={url} controls className=\"w-full rounded-lg\" />\n         <Button onClick={onDownload}>Download MP4</Button>\n       </div>\n     )\n   }\n   ```\n\n7. Create image preview similarly\n\n8. Create generation page (src/app/(dashboard)/generate/page.tsx):\n   - Tabs for Video/Image\n   - Form with prompt, model selector, format options, brand toggle\n   - Generate button with loading state\n   - Preview area showing result",
        "testStrategy": "1. Integration test: POST /api/generate/video with valid input returns video URL\n2. Integration test: POST /api/generate/image returns image data\n3. Integration test: Generation with includeBrand=true fetches brand context\n4. Integration test: Generation creates history record\n5. Component test: ModelSelector displays pricing correctly\n6. Component test: FormatSelector constrains options based on content type\n7. E2E test: Full generation flow - enter prompt, select options, generate, preview, download",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Generation History and Dashboard",
        "description": "Create history API endpoint with pagination, build history display page, and create the main dashboard with quick actions and recent generation overview.",
        "details": "1. Create history API route (src/app/api/history/route.ts):\n   ```typescript\n   import { NextRequest } from 'next/server'\n   import { prisma } from '@/lib/db'\n   import { requireAuth } from '@/lib/auth/session'\n   import { successResponse, errorResponse } from '@/lib/utils'\n\n   export async function GET(req: NextRequest) {\n     try {\n       const user = await requireAuth()\n       const { searchParams } = new URL(req.url)\n       const page = parseInt(searchParams.get('page') || '1')\n       const pageSize = parseInt(searchParams.get('pageSize') || '10')\n\n       const [generations, total] = await Promise.all([\n         prisma.generation.findMany({\n           where: { userId: user.id },\n           orderBy: { createdAt: 'desc' },\n           skip: (page - 1) * pageSize,\n           take: pageSize\n         }),\n         prisma.generation.count({ where: { userId: user.id } })\n       ])\n\n       return successResponse({\n         data: generations,\n         page,\n         pageSize,\n         total,\n         hasMore: page * pageSize < total\n       })\n     } catch (error) {\n       return errorResponse(error)\n     }\n   }\n   ```\n\n2. Create history page (src/app/(dashboard)/history/page.tsx):\n   ```typescript\n   'use client'\n   import { useState, useEffect } from 'react'\n   import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\n   import { Button } from '@/components/ui/button'\n\n   export default function HistoryPage() {\n     const [generations, setGenerations] = useState([])\n     const [page, setPage] = useState(1)\n     const [hasMore, setHasMore] = useState(false)\n\n     useEffect(() => {\n       fetch(`/api/history?page=${page}`)\n         .then(res => res.json())\n         .then(data => {\n           setGenerations(prev => page === 1 ? data.data.data : [...prev, ...data.data.data])\n           setHasMore(data.data.hasMore)\n         })\n     }, [page])\n\n     return (\n       <div className=\"container py-8\">\n         <h1 className=\"text-2xl font-bold mb-6\">Generation History</h1>\n         <div className=\"space-y-4\">\n           {generations.map((gen: any) => (\n             <Card key={gen.id}>\n               <CardHeader>\n                 <CardTitle className=\"text-sm font-medium\">\n                   {gen.contentType} - {new Date(gen.createdAt).toLocaleString()}\n                 </CardTitle>\n               </CardHeader>\n               <CardContent>\n                 <p className=\"text-sm text-muted-foreground truncate\">{gen.prompt}</p>\n                 <div className=\"flex gap-2 mt-2 text-xs\">\n                   <span>{gen.model}</span>\n                   <span>{gen.aspectRatio}</span>\n                   <span>{gen.resolution}</span>\n                   {gen.duration && <span>{gen.duration}s</span>}\n                 </div>\n               </CardContent>\n             </Card>\n           ))}\n         </div>\n         {hasMore && (\n           <Button onClick={() => setPage(p => p + 1)} className=\"mt-4\">\n             Load More\n           </Button>\n         )}\n       </div>\n     )\n   }\n   ```\n\n3. Create dashboard page (src/app/(dashboard)/dashboard/page.tsx):\n   ```typescript\n   import Link from 'next/link'\n   import { getSession } from '@/lib/auth/session'\n   import { prisma } from '@/lib/db'\n   import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\n   import { Button } from '@/components/ui/button'\n\n   export default async function DashboardPage() {\n     const session = await getSession()\n     const recentGenerations = await prisma.generation.findMany({\n       where: { userId: session!.user.id },\n       orderBy: { createdAt: 'desc' },\n       take: 5\n     })\n\n     return (\n       <div className=\"container py-8\">\n         <h1 className=\"text-2xl font-bold mb-6\">Dashboard</h1>\n\n         <div className=\"grid gap-4 md:grid-cols-2 mb-8\">\n           <Card>\n             <CardHeader>\n               <CardTitle>Create Video</CardTitle>\n             </CardHeader>\n             <CardContent>\n               <p className=\"text-sm text-muted-foreground mb-4\">\n                 Generate AI-powered video content for social media\n               </p>\n               <Link href=\"/generate?type=video\">\n                 <Button>Generate Video</Button>\n               </Link>\n             </CardContent>\n           </Card>\n           <Card>\n             <CardHeader>\n               <CardTitle>Create Image</CardTitle>\n             </CardHeader>\n             <CardContent>\n               <p className=\"text-sm text-muted-foreground mb-4\">\n                 Generate AI-powered images for posts and stories\n               </p>\n               <Link href=\"/generate?type=image\">\n                 <Button>Generate Image</Button>\n               </Link>\n             </CardContent>\n           </Card>\n         </div>\n\n         <h2 className=\"text-xl font-semibold mb-4\">Recent Generations</h2>\n         {/* Recent generations list */}\n       </div>\n     )\n   }\n   ```\n\n4. Create dashboard layout (src/app/(dashboard)/layout.tsx) with navigation sidebar/navbar",
        "testStrategy": "1. Integration test: GET /api/history returns paginated results\n2. Integration test: Pagination works correctly (page 2 shows different results)\n3. Integration test: History filters by authenticated user only\n4. Component test: History page renders generation cards correctly\n5. Component test: Dashboard shows quick action cards\n6. E2E test: Navigate dashboard -> generate -> complete generation -> verify in history",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Build Landing Page and Polish UI",
        "description": "Create the public landing page with product information and CTA, implement global error handling with toast notifications, and ensure responsive design across all pages.",
        "details": "1. Create landing page (src/app/page.tsx):\n   ```typescript\n   import Link from 'next/link'\n   import { Button } from '@/components/ui/button'\n\n   export default function LandingPage() {\n     return (\n       <div className=\"min-h-screen\">\n         {/* Hero Section */}\n         <section className=\"container py-24 text-center\">\n           <h1 className=\"text-4xl md:text-6xl font-bold mb-6\">\n             AI-Powered Content for <br /> Your Social Media\n           </h1>\n           <p className=\"text-xl text-muted-foreground mb-8 max-w-2xl mx-auto\">\n             Create professional videos and images in seconds. \n             No design skills required. Just describe what you want.\n           </p>\n           <div className=\"flex gap-4 justify-center\">\n             <Link href=\"/signup\">\n               <Button size=\"lg\">Get Started Free</Button>\n             </Link>\n             <Link href=\"/login\">\n               <Button variant=\"outline\" size=\"lg\">Sign In</Button>\n             </Link>\n           </div>\n         </section>\n\n         {/* Features Section */}\n         <section className=\"container py-16\">\n           <h2 className=\"text-3xl font-bold text-center mb-12\">Why ContentForge?</h2>\n           <div className=\"grid md:grid-cols-3 gap-8\">\n             <FeatureCard\n               title=\"AI Video Generation\"\n               description=\"Create stunning short-form videos for Reels and Stories\"\n             />\n             <FeatureCard\n               title=\"Brand Consistency\"\n               description=\"Your brand colors and voice in every generation\"\n             />\n             <FeatureCard\n               title=\"Instant Results\"\n               description=\"From idea to content in under 60 seconds\"\n             />\n           </div>\n         </section>\n\n         {/* CTA Section */}\n         <section className=\"container py-16 text-center\">\n           <h2 className=\"text-3xl font-bold mb-4\">Ready to transform your content?</h2>\n           <Link href=\"/signup\">\n             <Button size=\"lg\">Start Creating Now</Button>\n           </Link>\n         </section>\n       </div>\n     )\n   }\n   ```\n\n2. Set up toast notifications:\n   ```bash\n   npx shadcn@latest add toast sonner\n   ```\n\n3. Create global error boundary (src/components/error-boundary.tsx) and add to root layout\n\n4. Create toast provider and hooks (src/lib/hooks/use-toast.ts)\n\n5. Update all forms to show toast on success/error:\n   ```typescript\n   import { toast } from 'sonner'\n\n   // On success\n   toast.success('Content generated successfully!')\n\n   // On error\n   toast.error('Failed to generate content. Please try again.')\n   ```\n\n6. Responsive design pass:\n   - Audit all pages on mobile (320px), tablet (768px), desktop (1024px+)\n   - Fix any layout issues with Tailwind responsive classes\n   - Ensure forms are usable on mobile\n   - Test video/image previews on small screens\n\n7. Create navbar component (src/components/layout/navbar.tsx):\n   - Logo linking to home\n   - Auth state: show Login/Signup or Dashboard/Logout\n   - Mobile hamburger menu\n\n8. Create footer component (src/components/layout/footer.tsx)",
        "testStrategy": "1. Visual review: Landing page renders correctly on all breakpoints\n2. Visual review: All dashboard pages are usable on mobile\n3. Component test: Navbar shows correct links based on auth state\n4. E2E test: Click CTA on landing -> navigate to signup\n5. Manual test: Trigger errors, verify toast notifications appear\n6. Accessibility audit: Run axe-core on all pages",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Email Service for Password Reset",
        "description": "Set up Resend email service for transactional emails, implement password reset token generation and validation, and create forgot/reset password flow.",
        "details": "1. Install Resend:\n   ```bash\n   npm install resend\n   ```\n\n2. Create email service (src/lib/email/index.ts):\n   ```typescript\n   import { Resend } from 'resend'\n\n   const resend = new Resend(process.env.RESEND_API_KEY)\n\n   export async function sendPasswordResetEmail(email: string, token: string) {\n     const resetUrl = `${process.env.NEXTAUTH_URL}/reset-password?token=${token}`\n\n     await resend.emails.send({\n       from: 'ContentForge <noreply@contentforge.app>',\n       to: email,\n       subject: 'Reset your password',\n       html: `\n         <h1>Password Reset</h1>\n         <p>Click the link below to reset your password:</p>\n         <a href=\"${resetUrl}\">${resetUrl}</a>\n         <p>This link expires in 1 hour.</p>\n         <p>If you didn't request this, ignore this email.</p>\n       `\n     })\n   }\n   ```\n\n3. Add password reset token to Prisma schema:\n   ```prisma\n   model PasswordResetToken {\n     id        String   @id @default(uuid())\n     userId    String\n     user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n     token     String   @unique\n     expiresAt DateTime\n     createdAt DateTime @default(now())\n   }\n   ```\n\n4. Create password reset utilities (src/lib/auth/password-reset.ts):\n   ```typescript\n   import { randomBytes } from 'crypto'\n   import { prisma } from '@/lib/db'\n   import { hashPassword } from './password'\n\n   export async function generateResetToken(userId: string): Promise<string> {\n     const token = randomBytes(32).toString('hex')\n     const expiresAt = new Date(Date.now() + 60 * 60 * 1000) // 1 hour\n\n     // Delete any existing tokens for this user\n     await prisma.passwordResetToken.deleteMany({ where: { userId } })\n\n     await prisma.passwordResetToken.create({\n       data: { userId, token, expiresAt }\n     })\n\n     return token\n   }\n\n   export async function validateResetToken(token: string) {\n     const resetToken = await prisma.passwordResetToken.findUnique({\n       where: { token },\n       include: { user: true }\n     })\n\n     if (!resetToken || resetToken.expiresAt < new Date()) {\n       return null\n     }\n\n     return resetToken\n   }\n\n   export async function resetPassword(token: string, newPassword: string) {\n     const resetToken = await validateResetToken(token)\n     if (!resetToken) throw new Error('Invalid or expired token')\n\n     const passwordHash = await hashPassword(newPassword)\n     await prisma.user.update({\n       where: { id: resetToken.userId },\n       data: { passwordHash }\n     })\n\n     await prisma.passwordResetToken.delete({ where: { id: resetToken.id } })\n   }\n   ```\n\n5. Create API routes:\n   - POST /api/auth/forgot-password - request reset\n   - POST /api/auth/reset-password - complete reset\n\n6. Update forgot-password and reset-password pages with forms",
        "testStrategy": "1. Unit test: generateResetToken creates token in database\n2. Unit test: validateResetToken returns null for expired tokens\n3. Unit test: resetPassword updates user password hash\n4. Integration test: Full forgot password flow sends email\n5. Integration test: Reset password with valid token succeeds\n6. Integration test: Reset password with invalid/expired token fails\n7. E2E test: Complete password reset flow with email verification (use test inbox)",
        "priority": "low",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-12T20:49:07.329Z",
      "updated": "2025-12-12T20:49:07.329Z",
      "description": "Tasks for master context"
    }
  }
}